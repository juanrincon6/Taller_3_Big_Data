####################### NEURAL NETWORK FINAL #######################

#--- Limpiar entorno
rm(list = ls())
gc()
closeAllConnections()

#--- Cargar librerías
if (!require("pacman")) install.packages("pacman")
library(pacman)

p_load(
  tidyverse, gbm, caret, nnet, keras, recipes, yardstick
)

#--- Configurar rutas
user <- Sys.getenv("USERNAME")
if (user == "judel") {
  base_path <- "C:/Users/judel/OneDrive/Documentos/ANDES/Semestre 2/Big data/tercera parte/Taller 3/input"
} else if(user == "e125379") {
  base_path <- "C:\\Users\\e125379\\OneDrive - Mastercard\\8. Uniandes\\6. Big Data\\4. Taller 3\\1. Data\\"
}

store_path <- file.path(base_path, "stores")
pred_path  <- file.path(base_path, "predicciones")
dir.create(pred_path, recursive = TRUE, showWarnings = FALSE)

#--- Cargar datos finales
train <- readRDS(file.path(store_path, "train_full_final.rds"))
test  <- readRDS(file.path(store_path, "test_full_final.rds"))

#--- Convertir factores
train$property_type <- as.factor(train$property_type)
test$property_type  <- as.factor(test$property_type)

#--- Crear log(price)
train <- train %>% mutate(logprice = log(price))

#--- Partición interna de entrenamiento
set.seed(1011)
inTrain <- createDataPartition(y = train$logprice, p = .7, list = FALSE)
bdtrain_is <- train[inTrain, ]
bdtest_is  <- train[-inTrain, ]

#--- Variables a usar
vars_modelo <- c(
  "surface_covered", "rooms", "bedrooms", "bathrooms",
  "property_type", "tiene_remodelado", "tiene_lujoso", "tiene_bbq",
  "tiene_balcon", "tiene_terraza", "tiene_vista", "tiene_club_house",
  "tiene_chimenea", "distancia_parque", "distancia_bus",
  "distancia_avenida_principal", "distancia_universidad",
  "distancia_policia", "distancia_restaurant", "distancia_colegio"
)

#--- Fórmula del modelo
fmla <- as.formula(paste("price ~", paste(vars_modelo, collapse = " + ")))

#--- Entrenar modelo nnet
set.seed(123)
nn_model <- nnet(
  fmla, data = bdtrain_is,
  size = 10,
  linout = TRUE,
  maxit = 500
)

#--- Predecir sobre hold-out interno
bdtest_is$yhat_nn <- predict(nn_model, newdata = bdtest_is)
bdtest_is$price_round <- round(bdtest_is$yhat_nn)

#--- MAE
MAE_nn <- mean(abs(bdtest_is$price - bdtest_is$yhat_nn))
MAE_nn_R <- mean(abs(bdtest_is$price - bdtest_is$price_round))
cat("MAE (Neural Network - nnet):", MAE_nn, "\n")
cat("MAE Redondeado:", MAE_nn_R, "\n")

#--- Predecir sobre conjunto test
test$price <- as.numeric(round(predict(nn_model, newdata = test)))

#--- Exportar archivo final
write_csv(
  test %>% select(property_id, price),
  file.path(pred_path, "submission_nn.csv")
)

################################################################################
######################### MODELOS CON KERAS ####################################
################################################################################

#--- Preparar datos para keras
rec <- recipe(logprice ~ ., data = bdtrain_is %>% select(all_of(vars_modelo), logprice)) %>%
  step_normalize(all_numeric()) %>%
  step_dummy(all_nominal())

prep_rec <- prep(rec)

x_train <- bake(prep_rec, new_data = bdtrain_is) %>% select(-logprice) %>% model.matrix(~ . - 1, data = .)
x_val   <- bake(prep_rec, new_data = bdtest_is) %>% select(-logprice) %>% model.matrix(~ . - 1, data = .)
x_test  <- bake(prep_rec, new_data = test %>% select(all_of(vars_modelo))) %>% model.matrix(~ . - 1, data = .)

y_train <- bdtrain_is$logprice
y_val   <- bdtest_is$logprice

#--- Modelo profundo
model_keras <- keras_model_sequential() %>%
  layer_dense(units = 64, activation = "relu", input_shape = ncol(x_train)) %>%
  layer_dropout(rate = 0.2) %>%
  layer_dense(units = 32, activation = "relu") %>%
  layer_dense(units = 1)

model_keras %>% compile(
  loss = "mean_squared_error",
  optimizer = optimizer_adam(),
  metrics = c("mean_squared_error")
)

#--- Entrenamiento
model_keras %>% fit(
  x = x_train,
  y = y_train,
  epochs = 50,
  batch_size = 32,
  validation_data = list(x_val, y_val),
  verbose = 2
)

#--- Evaluación
pred_val <- model_keras %>% predict(x_val)
rmse_val <- sqrt(mean((exp(pred_val) - exp(y_val))^2))
cat("RMSE validación (keras):", rmse_val, "\n")

#--- Predicción final sobre test
test$price_keras <- round(as.numeric(exp(model_keras %>% predict(x_test))))

#--- Exportar archivo final keras
write_csv(
  test %>% select(property_id, price_keras),
  file.path(pred_path, "submission_nn_keras.csv")
)

############################## MODELOS DE REDES NEURONALES ##############################

#--- Limpiar entorno
rm(list = ls())
gc()
closeAllConnections()
library(tensorflow)
library(reticulate)

#--- Cargar paquetes
if (!require("pacman")) install.packages("pacman")
library(pacman)

p_load(
  tidyverse, keras, recipes, yardstick, caret, readr
)

#--- Configurar rutas según usuario
user <- Sys.getenv("USERNAME")
if (user == "judel") {
  base_path <- "C:/Users/judel/OneDrive/Documentos/ANDES/Semestre 2/Big data/tercera parte/Taller 3/input"
} else if(user == "e125379") {
  base_path <- "C:\\Users\\e125379\\OneDrive - Mastercard\\8. Uniandes\\6. Big Data\\4. Taller 3\\1. Data\\"
}

store_path <- file.path(base_path, "stores")
pred_path  <- file.path(base_path, "predicciones")
dir.create(pred_path, recursive = TRUE, showWarnings = FALSE)

#--- Cargar datos
train <- readRDS(file.path(store_path, "train_full_final.rds"))
test  <- readRDS(file.path(store_path, "test_full_final.rds"))

#--- Convertir factores
train$property_type <- as.factor(train$property_type)
test$property_type  <- as.factor(test$property_type)

#--- Crear log(price)
train <- train %>% mutate(logprice = log(price))

#--- Partición interna
set.seed(1011)
inTrain <- createDataPartition(y = train$logprice, p = .7, list = FALSE)
bdtrain_is <- train[inTrain, ]
bdtest_is  <- train[-inTrain, ]

#--- Variables del modelo
vars_modelo <- c(
  "surface_covered", "rooms", "bedrooms", "bathrooms",
  "property_type", "tiene_remodelado", "tiene_lujoso", "tiene_bbq",
  "tiene_balcon", "tiene_terraza", "tiene_vista", "tiene_club_house",
  "tiene_chimenea", "distancia_parque", "distancia_bus",
  "distancia_avenida_principal", "distancia_universidad",
  "distancia_policia", "distancia_restaurant", "distancia_colegio"
)

#--- Preprocesamiento
rec <- recipe(logprice ~ ., data = bdtrain_is[, c(vars_modelo, "logprice")]) %>%
  step_dummy(all_nominal_predictors()) %>%
  step_normalize(all_numeric_predictors())

prep_rec <- prep(rec)
x_train <- bake(prep_rec, new_data = bdtrain_is) %>% select(-logprice)
y_train <- bdtrain_is$logprice
x_test <- bake(prep_rec, new_data = bdtest_is) %>% select(-logprice)
y_test <- bdtest_is$logprice
x_test_final <- bake(prep_rec, new_data = test)


#--- Función para entrenar, predecir y exportar
entrenar_modelo_nn <- function(nombre, arquitectura, epochs = 5) {
  modelo <- keras_model_sequential()
  for (capa in arquitectura) {
    modelo <- modelo %>% layer_dense(units = capa$units, activation = capa$activation, input_shape = ifelse(capa$input, ncol(x_train), NULL))
  }
  modelo <- modelo %>% layer_dense(units = 1)  # Capa de salida
  
  modelo %>% compile(
    loss = "mean_squared_error",
    optimizer = optimizer_rmsprop(),
    metrics = c("mean_squared_error")
  )
  
  modelo %>% fit(as.matrix(x_train), y_train, epochs = epochs, batch_size = 32, verbose = 0)
  
  # Predicción interna
  pred_is <- modelo %>% predict(as.matrix(x_test)) %>% as.vector()
  bdtest_is[[paste0("yhat_", nombre)]] <<- exp(pred_is)
  
  # Predicción final
  pred_test <- modelo %>% predict(as.matrix(x_test_final)) %>% as.vector()
  test[[paste0("price_", nombre)]] <<- round(exp(pred_test))
  
  # Exportar archivo
  write_csv(
    test %>% select(property_id, !!sym(paste0("price_", nombre))) %>%
      rename(price = !!sym(paste0("price_", nombre))),
    file.path(pred_path, paste0("submission_nn_", nombre, ".csv"))
  )
  
  # MAE
  mae <- mean(abs(exp(pred_is) - exp(y_test)))
  cat(paste0("MAE (", nombre, "): ", round(mae, 2), "\n"))
}

################################# MODELOS #################################

#--- Modelo Simple
entrenar_modelo_nn("simple", list(list(units = 1, activation = NULL, input = TRUE)))

#--- Modelo ReLU
entrenar_modelo_nn("relu", list(list(units = 1, activation = "relu", input = TRUE)))

#--- Modelo tanh
entrenar_modelo_nn("tanh", list(list(units = 1, activation = "tanh", input = TRUE)))

#--- Modelo Profundo
entrenar_modelo_nn("profundo", list(
  list(units = 64, activation = "relu", input = TRUE)
))

#--- Modelo Avanzado
entrenar_modelo_nn("avanzado", list(
  list(units = 64, activation = "relu", input = TRUE),
  list(units = 32, activation = "relu", input = FALSE)
), epochs = 15)

###################### COMPARACIÓN DE RESULTADOS ######################

#--- Comparación de MAE
mae_df <- tibble(
  modelo = c("simple", "relu", "tanh", "profundo", "avanzado"),
  MAE = c(
    mean(abs(bdtest_is$price - bdtest_is$yhat_simple)),
    mean(abs(bdtest_is$price - bdtest_is$yhat_relu)),
    mean(abs(bdtest_is$price - bdtest_is$yhat_tanh)),
    mean(abs(bdtest_is$price - bdtest_is$yhat_profundo)),
    mean(abs(bdtest_is$price - bdtest_is$yhat_avanzado))
  )
)
print(mae_df)
